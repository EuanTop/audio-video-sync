<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Audio Video Sync - Test Page</title>
  <style>
    * { box-sizing: border-box; }
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      max-width: 1200px;
      margin: 0 auto;
      padding: 20px;
      background: #f5f5f5;
    }
    
    .header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 20px;
    }
    
    .language-switch {
      background: none;
      color: #666;
      border: none;
      padding: 0;
      font-size: 14px;
      cursor: pointer;
      text-decoration: underline;
      transition: color 0.3s;
    }
    .language-switch:hover { 
      color: #999; 
      background: none !important;
    }
    
    h1 { color: #333; margin: 0; }
    .section {
      background: white;
      border-radius: 8px;
      padding: 20px;
      margin-bottom: 20px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    .video-inputs {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 15px;
    }
    .video-input {
      border: 2px dashed #ccc;
      border-radius: 8px;
      padding: 20px;
      text-align: center;
      cursor: pointer;
      transition: all 0.3s;
    }
    .video-input:hover { border-color: #007bff; background: #f8f9fa; }
    .video-input.has-file { border-color: #28a745; background: #e8f5e9; }
    .video-input input { display: none; }
    .video-input .label { font-size: 14px; color: #666; }
    .video-input .filename { font-size: 12px; color: #28a745; margin-top: 8px; word-break: break-all; }
    
    .reference-select {
      margin: 15px 0;
      padding: 10px;
      background: #fff3cd;
      border-radius: 4px;
    }
    
    button {
      background: #007bff;
      color: white;
      border: none;
      padding: 12px 24px;
      border-radius: 6px;
      font-size: 16px;
      cursor: pointer;
      transition: background 0.3s;
    }
    button:hover { background: #0056b3; }
    button:disabled { background: #ccc; cursor: not-allowed; }
    
    .progress {
      margin: 15px 0;
      padding: 10px;
      background: #e3f2fd;
      border-radius: 4px;
      display: none;
    }
    .progress.active { display: block; }
    
    .results {
      margin-top: 20px;
    }
    .result-item {
      padding: 15px;
      margin: 10px 0;
      border-radius: 6px;
      background: #f8f9fa;
      border-left: 4px solid #007bff;
    }
    .result-item.reference { border-left-color: #28a745; }
    .result-item .video-id { font-weight: bold; font-size: 16px; }
    .result-item .offset { font-size: 24px; color: #007bff; margin: 10px 0; }
    .result-item .confidence { font-size: 14px; color: #666; }
    .result-item .confidence.high { color: #28a745; }
    .result-item .confidence.medium { color: #ffc107; }
    .result-item .confidence.low { color: #dc3545; }
    
    .error { color: #dc3545; padding: 10px; background: #f8d7da; border-radius: 4px; }
    
    #log {
      background: #1e1e1e;
      color: #d4d4d4;
      padding: 15px;
      border-radius: 6px;
      font-family: 'Consolas', 'Monaco', monospace;
      font-size: 12px;
      max-height: 300px;
      overflow-y: auto;
      white-space: pre-wrap;
    }
  </style>
</head>
<body>
  <div class="header">
    <h1>üé¨ Audio Video Sync Test</h1>
    <button class="language-switch" onclick="toggleLanguage()">‰∏≠Êñá</button>
  </div>
  <p id="description">Multi-camera video synchronization test tool based on audio cross-correlation (using Web Audio API)</p>
  
  <div class="section">
    <h2 id="section1-title">1. Select Video Files</h2>
    <div class="video-inputs">
      <div class="video-input" onclick="document.getElementById('video0').click()">
        <input type="file" id="video0" accept="video/*" onchange="handleFileSelect(0, this)">
        <div class="label" id="video0-label">üìπ Video 1 (Cam 1)</div>
        <div class="filename" id="filename0"></div>
      </div>
      <div class="video-input" onclick="document.getElementById('video1').click()">
        <input type="file" id="video1" accept="video/*" onchange="handleFileSelect(1, this)">
        <div class="label" id="video1-label">üìπ Video 2 (Cam 2)</div>
        <div class="filename" id="filename1"></div>
      </div>
      <div class="video-input" onclick="document.getElementById('video2').click()">
        <input type="file" id="video2" accept="video/*" onchange="handleFileSelect(2, this)">
        <div class="label" id="video2-label">üìπ Video 3 (Cam 3)</div>
        <div class="filename" id="filename2"></div>
      </div>
      <div class="video-input" onclick="document.getElementById('video3').click()">
        <input type="file" id="video3" accept="video/*" onchange="handleFileSelect(3, this)">
        <div class="label" id="video3-label">üìπ Video 4 (Cam 4)</div>
        <div class="filename" id="filename3"></div>
      </div>
    </div>
    
    <div class="reference-select">
      <label>
        <strong id="reference-label">Reference Video (aligned with RFID data):</strong>
        <select id="referenceIndex">
          <option value="0" id="ref-option0">Video 1 (Cam 1)</option>
          <option value="1" id="ref-option1">Video 2 (Cam 2)</option>
          <option value="2" id="ref-option2">Video 3 (Cam 3)</option>
          <option value="3" id="ref-option3">Video 4 (Cam 4)</option>
        </select>
      </label>
    </div>
  </div>
  
  <div class="section">
    <h2 id="section2-title">2. Start Synchronization</h2>
    <button id="syncBtn" onclick="startSync()" disabled>Start Audio Sync Analysis</button>
    <div class="progress" id="progress">
      <span id="progressText">Preparing...</span>
    </div>
  </div>
  
  <div class="section results" id="resultsSection" style="display:none">
    <h2 id="section3-title">3. Sync Results</h2>
    <div id="results"></div>
  </div>
  
  <div class="section">
    <h2 id="log-title">Log</h2>
    <div id="log"></div>
  </div>

  <script>
    // Language support
    let currentLang = 'en';
    
    const translations = {
      en: {
        title: 'üé¨ Audio Video Sync Test',
        description: 'Multi-camera video synchronization test tool based on audio cross-correlation (using Web Audio API)',
        section1: '1. Select Video Files',
        section2: '2. Start Synchronization', 
        section3: '3. Sync Results',
        logTitle: 'Log',
        video1: 'üìπ Video 1 (Cam 1)',
        video2: 'üìπ Video 2 (Cam 2)',
        video3: 'üìπ Video 3 (Cam 3)',
        video4: 'üìπ Video 4 (Cam 4)',
        referenceLabel: 'Reference Video (aligned with RFID data):',
        refOption1: 'Video 1 (Cam 1)',
        refOption2: 'Video 2 (Cam 2)',
        refOption3: 'Video 3 (Cam 3)',
        refOption4: 'Video 4 (Cam 4)',
        syncBtn: 'Start Audio Sync Analysis',
        progressText: 'Preparing...',
        langBtn: '‰∏≠Êñá',
        // Dynamic messages
        selectedVideo: 'Selected video',
        extractingAudio: 'Extracting audio from video',
        videoDuration: 'Video duration',
        analyzing: 'analyzing first',
        audioExtracted: 'Audio extraction completed',
        samples: 'samples',
        calculatingOffset: 'Calculating offset for video',
        relativeToRef: 'relative to reference video',
        offset: 'Offset',
        confidence: 'Confidence',
        error: 'Error',
        syncFailed: 'Sync failed',
        referenceVideo: 'Reference Video:',
        baseTime: 'Base Time',
        delayed: 'delayed',
        ahead: 'ahead',
        high: 'High',
        medium: 'Medium', 
        low: 'Low',
        offsetSamples: 'Offset samples',
        sampleRate: 'Sample rate',
        toolReady: 'Audio sync tool ready (using Web Audio API)',
        selectAtLeast2: 'Please select at least 2 video files',
        refNotSelected: 'Reference video not selected'
      },
      zh: {
        title: 'üé¨ Audio Video Sync ÊµãËØï',
        description: 'Âü∫‰∫éÈü≥È¢ë‰∫íÁõ∏ÂÖ≥ÁöÑÂ§öÊú∫‰ΩçËßÜÈ¢ëÂêåÊ≠•ÊµãËØïÂ∑•ÂÖ∑Ôºà‰ΩøÁî® Web Audio APIÔºâ',
        section1: '1. ÈÄâÊã©ËßÜÈ¢ëÊñá‰ª∂',
        section2: '2. ÂºÄÂßãÂêåÊ≠•',
        section3: '3. ÂêåÊ≠•ÁªìÊûú', 
        logTitle: 'Êó•Âøó',
        video1: 'üìπ ËßÜÈ¢ë 1 (Cam 1)',
        video2: 'üìπ ËßÜÈ¢ë 2 (Cam 2)',
        video3: 'üìπ ËßÜÈ¢ë 3 (Cam 3)',
        video4: 'üìπ ËßÜÈ¢ë 4 (Cam 4)',
        referenceLabel: 'ÂèÇËÄÉËßÜÈ¢ëÔºà‰∏é RFID Êï∞ÊçÆÂØπÈΩêÁöÑËßÜÈ¢ëÔºâÔºö',
        refOption1: 'ËßÜÈ¢ë 1 (Cam 1)',
        refOption2: 'ËßÜÈ¢ë 2 (Cam 2)',
        refOption3: 'ËßÜÈ¢ë 3 (Cam 3)',
        refOption4: 'ËßÜÈ¢ë 4 (Cam 4)',
        syncBtn: 'ÂºÄÂßãÈü≥È¢ëÂêåÊ≠•ÂàÜÊûê',
        progressText: 'ÂáÜÂ§á‰∏≠...',
        langBtn: 'English',
        // Dynamic messages
        selectedVideo: 'Â∑≤ÈÄâÊã©ËßÜÈ¢ë',
        extractingAudio: 'Ê≠£Âú®ÊèêÂèñËßÜÈ¢ë',
        videoDuration: 'ËßÜÈ¢ëÊó∂Èïø',
        analyzing: 'ÂàÜÊûêÂâç',
        audioExtracted: 'Èü≥È¢ëÊèêÂèñÂÆåÊàê',
        samples: '‰∏™ÈááÊ†∑ÁÇπ',
        calculatingOffset: 'Ê≠£Âú®ËÆ°ÁÆóËßÜÈ¢ë',
        relativeToRef: 'Áõ∏ÂØπ‰∫éÂèÇËÄÉËßÜÈ¢ëÁöÑÂÅèÁßª',
        offset: 'ÂÅèÁßª',
        confidence: 'ÁΩÆ‰ø°Â∫¶',
        error: 'ÈîôËØØ',
        syncFailed: 'ÂêåÊ≠•Â§±Ë¥•',
        referenceVideo: 'ÂèÇËÄÉËßÜÈ¢ë:',
        baseTime: 'Âü∫ÂáÜÊó∂Èó¥',
        delayed: 'Âª∂Ëøü',
        ahead: 'È¢ÜÂÖà',
        high: 'È´ò',
        medium: '‰∏≠',
        low: '‰Ωé',
        offsetSamples: 'ÂÅèÁßªÈááÊ†∑ÁÇπ',
        sampleRate: 'ÈááÊ†∑Áéá',
        toolReady: 'Èü≥È¢ëÂêåÊ≠•Â∑•ÂÖ∑Â∑≤Â∞±Áª™Ôºà‰ΩøÁî® Web Audio APIÔºâ',
        selectAtLeast2: 'ËØ∑Ëá≥Â∞ëÈÄâÊã© 2 ‰∏™ËßÜÈ¢ëÊñá‰ª∂',
        refNotSelected: 'ÂèÇËÄÉËßÜÈ¢ëÊú™ÈÄâÊã©'
      }
    };
    
    const updateLanguage = () => {
      const t = translations[currentLang];
      document.querySelector('h1').textContent = t.title;
      document.getElementById('description').textContent = t.description;
      document.getElementById('section1-title').textContent = t.section1;
      document.getElementById('section2-title').textContent = t.section2;
      document.getElementById('section3-title').textContent = t.section3;
      document.getElementById('log-title').textContent = t.logTitle;
      document.getElementById('video0-label').textContent = t.video1;
      document.getElementById('video1-label').textContent = t.video2;
      document.getElementById('video2-label').textContent = t.video3;
      document.getElementById('video3-label').textContent = t.video4;
      document.getElementById('reference-label').textContent = t.referenceLabel;
      document.getElementById('ref-option0').textContent = t.refOption1;
      document.getElementById('ref-option1').textContent = t.refOption2;
      document.getElementById('ref-option2').textContent = t.refOption3;
      document.getElementById('ref-option3').textContent = t.refOption4;
      document.getElementById('syncBtn').textContent = t.syncBtn;
      document.getElementById('progressText').textContent = t.progressText;
      document.querySelector('.language-switch').textContent = t.langBtn;
      document.documentElement.lang = currentLang === 'en' ? 'en' : 'zh-CN';
    };
    
    window.toggleLanguage = () => {
      currentLang = currentLang === 'en' ? 'zh' : 'en';
      updateLanguage();
    };
    
    // Global variables
    window.videoFiles = [null, null, null, null];
    
    const log = (msg) => {
      const logEl = document.getElementById('log');
      const time = new Date().toLocaleTimeString();
      logEl.textContent += `[${time}] ${msg}\n`;
      logEl.scrollTop = logEl.scrollHeight;
      console.log(msg);
    };
    
    // Êñá‰ª∂ÈÄâÊã©Â§ÑÁêÜ
    window.handleFileSelect = (index, input) => {
      const file = input.files[0];
      if (file) {
        window.videoFiles[index] = file;
        document.getElementById(`filename${index}`).textContent = file.name;
        input.parentElement.classList.add('has-file');
        const t = translations[currentLang];
        log(`${t.selectedVideo} ${index + 1}: ${file.name}`);
        updateSyncButton();
      }
    };
    
    const updateSyncButton = () => {
      const hasFiles = window.videoFiles.filter(f => f).length >= 2;
      document.getElementById('syncBtn').disabled = !hasFiles;
    };
    
    // ‰ΩøÁî® Web Audio API ÊèêÂèñÈü≥È¢ë
    const extractAudioFromVideo = async (file, index) => {
      const t = translations[currentLang];
      log(`${t.extractingAudio} ${index + 1} ${currentLang === 'en' ? 'audio...' : 'ÁöÑÈü≥È¢ë...'}`);
      
      return new Promise((resolve, reject) => {
        const video = document.createElement('video');
        video.muted = true;
        video.src = URL.createObjectURL(file);
        
        video.onloadedmetadata = async () => {
          const duration = Math.min(video.duration, 30); // ÊúÄÂ§ö30Áßí
          log(`${currentLang === 'en' ? 'Video' : 'ËßÜÈ¢ë'} ${index + 1} ${t.videoDuration}: ${video.duration.toFixed(2)}s, ${t.analyzing} ${duration.toFixed(2)}s`);
          
          try {
            // ‰ΩøÁî® AudioContext Ëß£Á†ÅÈü≥È¢ë
            const audioContext = new (window.AudioContext || window.webkitAudioContext)();
            
            // ËØªÂèñÊñá‰ª∂‰∏∫ ArrayBuffer
            const arrayBuffer = await file.arrayBuffer();
            
            // Ëß£Á†ÅÈü≥È¢ë
            const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
            
            // Ëé∑ÂèñÂçïÂ£∞ÈÅìÊï∞ÊçÆ
            let samples;
            if (audioBuffer.numberOfChannels === 1) {
              samples = audioBuffer.getChannelData(0);
            } else {
              // Ê∑∑Âêà‰∏∫ÂçïÂ£∞ÈÅì
              const length = audioBuffer.length;
              samples = new Float32Array(length);
              const numChannels = audioBuffer.numberOfChannels;
              for (let ch = 0; ch < numChannels; ch++) {
                const channelData = audioBuffer.getChannelData(ch);
                for (let i = 0; i < length; i++) {
                  samples[i] += channelData[i] / numChannels;
                }
              }
            }
            
            // ÈôçÈááÊ†∑Âà∞ 16000 Hz
            const targetSampleRate = 16000;
            const ratio = audioBuffer.sampleRate / targetSampleRate;
            const maxSamples = Math.floor(duration * targetSampleRate);
            const downsampledLength = Math.min(Math.floor(samples.length / ratio), maxSamples);
            const downsampled = new Float32Array(downsampledLength);
            
            for (let i = 0; i < downsampledLength; i++) {
              downsampled[i] = samples[Math.floor(i * ratio)];
            }
            
            log(`${currentLang === 'en' ? 'Video' : 'ËßÜÈ¢ë'} ${index + 1} ${t.audioExtracted}, ${downsampled.length} ${t.samples} (${(downsampled.length / targetSampleRate).toFixed(2)}s)`);
            
            URL.revokeObjectURL(video.src);
            audioContext.close();
            
            resolve(downsampled);
          } catch (err) {
            URL.revokeObjectURL(video.src);
            reject(err);
          }
        };
        
        video.onerror = () => {
          URL.revokeObjectURL(video.src);
          reject(new Error(`${t.error}: ${currentLang === 'en' ? 'Cannot load video' : 'Êó†Ê≥ïÂä†ËΩΩËßÜÈ¢ë'} ${index + 1}`));
        };
      });
    };
    
    // È¢ÑÂ§ÑÁêÜÈü≥È¢ë
    const preprocessAudio = (samples) => {
      const result = new Float32Array(samples.length);
      
      let sum = 0;
      for (let i = 0; i < samples.length; i++) {
        sum += samples[i];
      }
      const mean = sum / samples.length;
      
      let maxAbs = 0;
      for (let i = 0; i < samples.length; i++) {
        result[i] = samples[i] - mean;
        maxAbs = Math.max(maxAbs, Math.abs(result[i]));
      }
      
      if (maxAbs > 0) {
        for (let i = 0; i < result.length; i++) {
          result[i] /= maxAbs;
        }
      }
      
      return result;
    };
    
    // FFT ÂÆûÁé∞
    const nextPowerOfTwo = (n) => 1 << Math.ceil(Math.log2(n));
    
    const fft = (input) => {
      const n = input.length;
      
      if (n === 1) return [[input[0], 0]];
      
      const even = new Float32Array(n / 2);
      const odd = new Float32Array(n / 2);
      
      for (let i = 0; i < n / 2; i++) {
        even[i] = input[2 * i];
        odd[i] = input[2 * i + 1];
      }
      
      const evenFFT = fft(even);
      const oddFFT = fft(odd);
      
      const result = new Array(n);
      
      for (let k = 0; k < n / 2; k++) {
        const angle = -2 * Math.PI * k / n;
        const twiddle = [Math.cos(angle), Math.sin(angle)];
        
        const t = [
          twiddle[0] * oddFFT[k][0] - twiddle[1] * oddFFT[k][1],
          twiddle[0] * oddFFT[k][1] + twiddle[1] * oddFFT[k][0]
        ];
        
        result[k] = [evenFFT[k][0] + t[0], evenFFT[k][1] + t[1]];
        result[k + n / 2] = [evenFFT[k][0] - t[0], evenFFT[k][1] - t[1]];
      }
      
      return result;
    };
    
    const ifft = (input) => {
      const n = input.length;
      const conjugated = input.map(([re, im]) => [re, -im]);
      const result = fftComplex(conjugated);
      return result.map(([re, im]) => [re / n, -im / n]);
    };
    
    const fftComplex = (input) => {
      const n = input.length;
      
      if (n === 1) return [input[0]];
      
      const even = [];
      const odd = [];
      
      for (let i = 0; i < n / 2; i++) {
        even.push(input[2 * i]);
        odd.push(input[2 * i + 1]);
      }
      
      const evenFFT = fftComplex(even);
      const oddFFT = fftComplex(odd);
      
      const result = new Array(n);
      
      for (let k = 0; k < n / 2; k++) {
        const angle = -2 * Math.PI * k / n;
        const twiddle = [Math.cos(angle), Math.sin(angle)];
        
        const t = [
          twiddle[0] * oddFFT[k][0] - twiddle[1] * oddFFT[k][1],
          twiddle[0] * oddFFT[k][1] + twiddle[1] * oddFFT[k][0]
        ];
        
        result[k] = [evenFFT[k][0] + t[0], evenFFT[k][1] + t[1]];
        result[k + n / 2] = [evenFFT[k][0] - t[0], evenFFT[k][1] - t[1]];
      }
      
      return result;
    };
    
    // ‰∫íÁõ∏ÂÖ≥
    const crossCorrelate = (signalA, signalB) => {
      const n = nextPowerOfTwo(signalA.length + signalB.length - 1);
      
      const paddedA = new Float32Array(n);
      const paddedB = new Float32Array(n);
      paddedA.set(signalA);
      paddedB.set(signalB);
      
      const fftA = fft(paddedA);
      const fftB = fft(paddedB);
      
      const product = fftA.map((a, i) => {
        const b = fftB[i];
        return [
          a[0] * b[0] + a[1] * b[1],
          a[1] * b[0] - a[0] * b[1]
        ];
      });
      
      const correlation = ifft(product);
      
      const result = new Float32Array(n);
      for (let i = 0; i < n; i++) {
        result[i] = correlation[i][0];
      }
      
      return result;
    };
    
    const findPeakOffset = (correlation, signalBLength) => {
      let maxValue = -Infinity;
      let maxIndex = 0;
      
      for (let i = 0; i < correlation.length; i++) {
        if (correlation[i] > maxValue) {
          maxValue = correlation[i];
          maxIndex = i;
        }
      }
      
      const n = correlation.length;
      if (maxIndex > n / 2) {
        return maxIndex - n;
      }
      return maxIndex;
    };
    
    const calculateConfidence = (signalA, signalB, correlation, peakIndex) => {
      const idx = peakIndex < 0 ? correlation.length + peakIndex : peakIndex;
      const maxCorr = correlation[idx];
      
      let energyA = 0, energyB = 0;
      for (let i = 0; i < signalA.length; i++) energyA += signalA[i] * signalA[i];
      for (let i = 0; i < signalB.length; i++) energyB += signalB[i] * signalB[i];
      
      const normFactor = Math.sqrt(energyA * energyB);
      if (normFactor === 0) return 0;
      
      return Math.abs(maxCorr) / normFactor;
    };
    
    // ÂºÄÂßãÂêåÊ≠•
    window.startSync = async () => {
      const videos = window.videoFiles.filter(f => f);
      const t = translations[currentLang];
      
      if (videos.length < 2) {
        alert(t.selectAtLeast2);
        return;
      }
      
      const referenceIndex = parseInt(document.getElementById('referenceIndex').value);
      const sampleRate = 16000;
      
      document.getElementById('syncBtn').disabled = true;
      document.getElementById('progress').classList.add('active');
      document.getElementById('resultsSection').style.display = 'none';
      
      try {
        // ÊèêÂèñÊâÄÊúâÈü≥È¢ë
        const audioData = [];
        const validIndices = [];
        
        for (let i = 0; i < 4; i++) {
          if (window.videoFiles[i]) {
            document.getElementById('progressText').textContent = 
              `${t.extractingAudio} ${i + 1} ${currentLang === 'en' ? 'audio...' : 'ÁöÑÈü≥È¢ë...'}`;
            const samples = await extractAudioFromVideo(window.videoFiles[i], i);
            audioData.push(preprocessAudio(samples));
            validIndices.push(i);
          }
        }
        
        // ÊâæÂà∞ÂèÇËÄÉËßÜÈ¢ëÂú®ÊúâÊïàÁ¥¢Âºï‰∏≠ÁöÑ‰ΩçÁΩÆ
        const refIndexInValid = validIndices.indexOf(referenceIndex);
        if (refIndexInValid === -1) {
          throw new Error(t.refNotSelected);
        }
        
        const referenceAudio = audioData[refIndexInValid];
        
        // ËÆ°ÁÆóÂÅèÁßª
        const results = [];
        
        for (let i = 0; i < validIndices.length; i++) {
          const videoIndex = validIndices[i];
          
          if (i === refIndexInValid) {
            results.push({
              videoIndex,
              offsetSeconds: 0,
              offsetSamples: 0,
              confidence: 1,
              isReference: true
            });
            continue;
          }
          
          document.getElementById('progressText').textContent = 
            `${t.calculatingOffset} ${videoIndex + 1} ${currentLang === 'en' ? 'offset...' : 'ÁöÑÂÅèÁßª...'}`;
          
          log(`${t.calculatingOffset} ${videoIndex + 1} ${t.relativeToRef}...`);
          
          const targetAudio = audioData[i];
          const correlation = crossCorrelate(referenceAudio, targetAudio);
          const offsetSamples = findPeakOffset(correlation, targetAudio.length);
          const offsetSeconds = offsetSamples / sampleRate;
          const confidence = calculateConfidence(referenceAudio, targetAudio, correlation, offsetSamples);
          
          log(`${currentLang === 'en' ? 'Video' : 'ËßÜÈ¢ë'} ${videoIndex + 1}: ${t.offset} = ${offsetSeconds.toFixed(3)}s, ${t.confidence} = ${(confidence * 100).toFixed(1)}%`);
          
          results.push({
            videoIndex,
            offsetSeconds,
            offsetSamples,
            confidence,
            isReference: false
          });
        }
        
        // ÊòæÁ§∫ÁªìÊûú
        displayResults(results, referenceIndex);
        
      } catch (err) {
        log(`${t.error}: ${err.message}`);
        console.error(err);
        document.getElementById('results').innerHTML = 
          `<div class="error">${t.syncFailed}: ${err.message}</div>`;
        document.getElementById('resultsSection').style.display = 'block';
      } finally {
        document.getElementById('syncBtn').disabled = false;
        document.getElementById('progress').classList.remove('active');
      }
    };
    
    const displayResults = (results, referenceIndex) => {
      const resultsEl = document.getElementById('results');
      const t = translations[currentLang];
      
      let html = `<p><strong>${t.referenceVideo}</strong> ${currentLang === 'en' ? 'Video' : 'ËßÜÈ¢ë'} ${referenceIndex + 1}</p>`;
      
      results.forEach(r => {
        const confidenceClass = r.confidence >= 0.7 ? 'high' : r.confidence >= 0.4 ? 'medium' : 'low';
        const offsetStr = r.offsetSeconds >= 0 
          ? `+${r.offsetSeconds.toFixed(3)}s (${t.delayed})` 
          : `${r.offsetSeconds.toFixed(3)}s (${t.ahead})`;
        
        const confidenceText = r.confidence >= 0.7 ? `‚úì ${t.high}` : r.confidence >= 0.4 ? `‚ö† ${t.medium}` : `‚úó ${t.low}`;
        
        html += `
          <div class="result-item ${r.isReference ? 'reference' : ''}">
            <div class="video-id">
              ${currentLang === 'en' ? 'Video' : 'ËßÜÈ¢ë'} ${r.videoIndex + 1} 
              ${r.isReference ? (currentLang === 'en' ? '(Reference)' : '(ÂèÇËÄÉ)') : ''}
            </div>
            <div class="offset">
              ${r.isReference ? t.baseTime : offsetStr}
            </div>
            <div class="confidence ${confidenceClass}">
              ${t.confidence}: ${(r.confidence * 100).toFixed(1)}%
              ${confidenceText}
            </div>
            ${!r.isReference ? `
              <div style="margin-top:10px;font-size:12px;color:#666;">
                ${t.offsetSamples}: ${r.offsetSamples} (${t.sampleRate}: 16000 Hz)
              </div>
            ` : ''}
          </div>
        `;
      });
      
      resultsEl.innerHTML = html;
      document.getElementById('resultsSection').style.display = 'block';
    };
    
    // Initialize
    updateLanguage();
    log(translations[currentLang].toolReady);
    updateSyncButton();
  </script>
</body>
</html>
